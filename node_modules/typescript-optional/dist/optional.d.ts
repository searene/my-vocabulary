import { Cases, Option } from "./types";
export declare abstract class Optional<T> {
    abstract isPresent(): boolean;
    isEmpty(): boolean;
    abstract get(): T;
    abstract ifPresent(consumer: (value: T) => void): void;
    abstract ifPresentOrElse(consumer: (value: T) => void, emptyAction: () => void): void;
    abstract filter(predicate: (value: T) => boolean): Optional<T>;
    abstract map<U>(mapper: (value: T) => U): Optional<NonNullable<U>>;
    abstract flatMap<U>(mapper: (value: T) => Optional<U>): Optional<U>;
    abstract or(supplier: () => Optional<T>): Optional<T>;
    abstract orElse(another: T): T;
    abstract orElseGet(supplier: () => T): T;
    abstract orElseThrow<U>(errorSupplier: () => U): T;
    abstract orNull(): T | null;
    abstract orUndefined(): T | undefined;
    abstract toOption(): Option<T>;
    abstract matches<U>(cases: Cases<T, U>): U;
    abstract toJSON(key: string): unknown;
    static of<T>(value: T): Optional<T>;
    static ofNonNull<T>(value: T): Optional<T>;
    static ofNullable<T>(nullable: T | null | undefined): Optional<T>;
    static empty<T>(): Optional<T>;
    static from<T>(option: Option<T>): Optional<T>;
}
